import os
import re
import requests
from openad.helpers.output import output_error, output_warning, output_text

this_dir = os.path.dirname(os.path.abspath(__file__))
docs_dir = os.path.normpath(os.path.join(this_dir, "../../main/docs"))
source_dir = os.path.normpath(os.path.join(this_dir, "../_source"))
template_dir = os.path.normpath(os.path.join(this_dir, "../_templates"))
output_dir = os.path.normpath(os.path.join(this_dir, "../_output"))
openad_toolkit_dir = os.path.normpath(os.path.join(this_dir, "../../../openad-toolkit"))


FLAG_SUCCESS = f"<on_green> SUCCESS </on_green>"
FLAG_ERROR = f"<on_red> FAILED </on_red>"
DO_NOT_EDIT = (
    "<!--\n\n"
    "DO NOT EDIT\n"
    "-----------\n"
    "This file is auto-generated.\n"
    "To update it, consult instructions:\n"
    "https://github.com/acceleratedscience/openad-website/tree/generator\n\n"
    "-->"
)
AUTOGENERATE_NOTICE = (
    "<!--\n\n"
    "Attention\n"
    "---------\n"
    "One or more descriptions in this file have been auto-generated\n"
    "by the generate_docs() script in @openad-website/generator.\n\n"
    "For more info:\n"
    "https://github.com/acceleratedscience/openad-website/tree/generator\n\n"
    "-->"
)


def read_template_file(filename):
    """Return the content of a file from the input dir."""
    path = os.path.join(template_dir, filename)
    return _read_file_content(path)


def read_source_file(filename):
    """Return the content of a file from the source dir."""
    path = os.path.join(source_dir, filename)
    return _read_file_content(path)


def read_docs_file(filename):
    """Return the content of a file from /docs."""
    path = os.path.join(docs_dir, filename)
    return _read_file_content(path)


def read_oad_file(filename):
    """Return the content of a file from the openad-toolkit repo."""
    path = os.path.join(openad_toolkit_dir, filename)
    return _read_file_content(path)


def fetch_gh_file(filename, branch="main"):
    """
    Fetch a file from the OpenAD GitHub repository and return its content.
    """

    try:
        url = f"https://raw.githubusercontent.com/acceleratedscience/openad-toolkit/{branch}/{filename}"
        output_text(f"<soft>Fetching {filename} from {branch} branch</soft>")
        response = requests.get(url, timeout=10)

        if response.status_code == 200:
            return response.text
        else:
            output_text(FLAG_ERROR, pad_top=1)
            output_error(f"Failed to fetch {filename} from {url}")
            return None

    except requests.RequestException as e:
        output_text(FLAG_ERROR, pad_top=1)
        output_error(f"Request failed: {str(e)}")
        return None


def update_autogenerated_section(src_text, section_name, content):
    """
    Scan the source text for a specific autogenerated section and replace it with new content.

    Also update the autogenerated:notice
    """
    match_str = rf"<!-- autogenerated:{section_name} -->.*<!-- /autogenerated:{section_name} -->"

    # Update or add the autogenerated notice on top
    if section_name != "notice":  # Prevent recursive loop
        added_notice = update_autogenerated_section(
            src_text, "notice", AUTOGENERATE_NOTICE
        )
        if added_notice:
            src_text = added_notice
        else:
            src_text = (
                f"<!-- autogenerated:notice -->\n{AUTOGENERATE_NOTICE}\n<!-- /autogenerated:notice -->\n\n"
                + src_text
            )
            output_warning("Added missing autogenerated:notice")

    # Error
    if not re.search(match_str, src_text, flags=re.DOTALL):
        output_text(FLAG_ERROR, pad_top=1)
        output_error(
            f"Section not found in the source text: <soft><!-- autogenerated:{section_name} --></soft>"
        )
        return None

    # Success
    return re.sub(
        rf"<!-- autogenerated:{section_name} -->.*<!-- /autogenerated:{section_name} -->",
        f"<!-- autogenerated:{section_name} -->\n{content.strip()}\n<!-- /autogenerated:{section_name} -->",
        src_text,
        flags=re.DOTALL,
    )


def write_output_file(filename, content):
    """Write content to a file in the output directory."""
    try:
        with open(os.path.join(output_dir, filename), "w", encoding="utf-8") as f:
            f.write(content)
        output_text(FLAG_SUCCESS)
        output_text(f"<soft>Exported to</soft> <reset>/output/{filename}</reset>")
    except Exception as e:
        output_text(FLAG_ERROR)
        output_error(str(e))


#
#
#


def _read_file_content(path):
    """Return the content of a file."""
    content = None
    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception as e:
        output_text(FLAG_ERROR, pad_top=1)
        output_error([str(e), path])
        return

    return content
